
<html>
<!-- pacman v1.0 -->
<!-- February 14, 2016 -->

<head>
  <title>PacMan</title>
  <link href="css_files/pacMan.css" rel="stylesheet">
  <script>//todo feature list

//unique ghost AI per ghost  <-- 3/4 way done
//fix ghost going through walls  <-- probably should be done first  <--- finsihed
//make power pellets work... add in proper AI first
//level system
//strawberrys/cherrys???
//teleporting side paths
//proper ghost realease
//bigger map <-- finished
//pacman and ghost dynamicaly change size with the gridSize <--- finished
//reset button
//stats area
//make a display screen like in the arcade where it introduces the ghost and pac man
//after bigger map make dynamic walls
//fix ghost movement bug    <--- finsihed
//make a way for ghost to know how to exit ghost house

function lvl1(){
  
  //level background data placement
  //0 = no wall with pellet
  //1 = wall
  //2 = no wall with no pellet
  //3 = power pellet
  
  levelRow = [];
  
  levelRow[0] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
  levelRow[1] = [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1];
  levelRow[2] = [1,3,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,3,1];
  levelRow[3] = [1,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,1];
  levelRow[4] = [1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,0,1];
  levelRow[5] = [1,0,0,0,1,1,0,1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,1,1,0,0,0,1];
  levelRow[6] = [1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1];
  levelRow[7] = [1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1];
  levelRow[8] = [1,0,0,0,0,1,0,1,0,1,1,0,0,0,2,2,2,2,2,2,2,0,0,0,1,1,0,1,0,1,0,0,0,0,1];
  levelRow[9] = [1,1,1,1,0,0,0,1,0,1,1,0,1,1,2,1,1,2,1,1,2,1,1,0,1,1,0,1,0,0,0,1,1,1,1];
  levelRow[10] =[1,0,0,1,0,1,1,1,0,1,1,0,1,1,2,1,2,2,2,1,2,1,1,0,1,1,0,1,1,1,0,1,0,0,1];
  levelRow[11] =[1,1,1,1,0,0,0,0,0,1,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,1,0,0,0,0,0,1,1,1,1];
  levelRow[12] =[1,0,0,0,0,1,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,1,1,1,0,0,0,0,1];
  levelRow[13] =[1,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1];
  levelRow[14] =[1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1];
  levelRow[15] =[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];
  levelRow[16] =[1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1];
  levelRow[17] =[1,3,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,3,1];
  levelRow[18] =[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1];
  levelRow[19] =[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
 
  
  //other level variables
  
  //pacman position
  pacManx = gridSize * 17;
  pacMany = gridSize * 12;
  
  //starting pacman direction
  direction = "left";
  lastTrueDirection = "left";//this needs set to prevent errors. make sure it is valid
  
  //score variables
  score = 0;
  maxScore = 3370;//total amount of pellets times 100
  
  //starting ghost varibles 
  ghostCount = 4;
  endMode = 0;
  ghostId = [];
  ghostX = [];
  ghostY = [];
  ghostsDirection = [];
  ghostLastTrueDirection = [];
  ghostSpeed = [];
  ghostTimer = [];
  ghostTimer = [0,0,15,15];
  ghost = [0,1,2,1];//this determines different AI Pattern
  ghostX = [(gridSize * 17), (gridSize * 17), (gridSize * 18), (gridSize * 16)];
  ghostY = [(gridSize * 9), (gridSize * 10), (gridSize * 10), (gridSize * 10)];
  ghostsDirection = ["up","up","left","right"];
  ghostLastTrueDirection = ["up","up","left","right"];
  ghostSpeed = [5,5,5,5];//make this a multible of whatever the gridSize is. like 2,5,10,25, and even 50 or if using a decimal make sure it adds up evenly to 50
  ghostColor = [];
  ghostColor = ["red","hotpink","skyblue","orange"];
  ghostMoveComplete = [];
  ghostMoveComplete = ["True","True","True","True"];
  newGhostx = [];
  newGhosty = [];
  ghostHouse = [];
  ghostHouse = [gridSize * 17,gridSize * 10];
  ghostSchedule = [];
  ghostSchedule = [20,7,20,7,20,5,20,5];
  
}

function lvl2(){
  
  //level background data placement
  //0 = no wall with pellet
  //1 = wall
  //2 = no wall with no pellet
  //3 = power pellet
  
  levelRow = [];
  
  levelRow[0] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
  levelRow[1] = [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1];
  levelRow[2] = [1,3,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,3,1];
  levelRow[3] = [1,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,1];
  levelRow[4] = [1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,0,1];
  levelRow[5] = [1,0,0,0,1,1,0,1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,1,1,0,0,0,1];
  levelRow[6] = [1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1];
  levelRow[7] = [1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1];
  levelRow[8] = [1,0,0,0,0,1,0,1,0,1,1,0,0,0,2,2,2,2,2,2,2,0,0,0,1,1,0,1,0,1,0,0,0,0,1];
  levelRow[9] = [1,1,1,1,0,0,0,1,0,1,1,0,1,1,2,1,1,2,1,1,2,1,1,0,1,1,0,1,0,0,0,1,1,1,1];
  levelRow[10] =[0,0,0,0,0,1,1,1,0,1,1,0,1,1,2,1,2,2,2,1,2,1,1,0,1,1,0,1,1,1,0,0,0,0,0];
  levelRow[11] =[1,1,1,1,0,0,0,0,0,1,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,1,0,0,0,0,0,1,1,1,1];
  levelRow[12] =[1,0,0,0,0,1,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,1,1,1,0,0,0,0,1];
  levelRow[13] =[1,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1];
  levelRow[14] =[1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1];
  levelRow[15] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  levelRow[16] =[1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1];
  levelRow[17] =[1,3,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,3,1];
  levelRow[18] =[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1];
  levelRow[19] =[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
 
  
  //other level variables
  
  //pacman position
  pacManx = gridSize * 17;
  pacMany = gridSize * 12;
  
  //starting pacman direction
  direction = "left";
  lastTrueDirection = "left";//this needs set to prevent errors. make sure it is valid
  
  //score variables
  score = 0;
  maxScore = 3370;//total amount of pellets times 100
  
  //starting ghost varibles 
  ghostCount = 4;
  endMode = 0;
  ghostId = [];
  ghostX = [];
  ghostY = [];
  ghostsDirection = [];
  ghostLastTrueDirection = [];
  ghostSpeed = [];
  ghostTimer = [];
  ghostTimer = [0,0,15,15];
  ghost = [0,1,2,1];//this determines different AI Pattern
  ghostX = [(gridSize * 17), (gridSize * 17), (gridSize * 18), (gridSize * 16)];
  ghostY = [(gridSize * 9), (gridSize * 10), (gridSize * 10), (gridSize * 10)];
  ghostsDirection = ["up","up","left","right"];
  ghostLastTrueDirection = ["up","up","left","right"];
  ghostSpeed = [5,5,5,5];//make this a multible of whatever the gridSize is. like 2,5,10,25, and even 50 or if using a decimal make sure it adds up evenly to 50
  ghostColor = [];
  ghostColor = ["red","hotpink","skyblue","orange"];
  ghostMoveComplete = [];
  ghostMoveComplete = ["True","True","True","True"];
  newGhostx = [];
  newGhosty = [];
  ghostHouse = [];
  ghostHouse = [gridSize * 17,gridSize * 10];
  ghostSchedule = [];
  ghostSchedule = [20,7,20,7,20,5,20,5];
  
}


</script>
  <script>function init() {

  //grid size of the game
  gridSize = 30;

  lvl1();

  //frame variables
  width = 1050;
  height = 600;

  //-------game variables--------
  //game mode
  play = "False";

  //pacman mouth angles for start
  topMouthAngle = 0;
  bottomMouthAngle = 0;

  //pacman eye heigth
  eyePosition = 12;

  //needed to prevent errors in movement
  pacCheck = "False";
  check = "False";
  moveComplete = "True";
  movementMemory = 0;
  mode = "normal";


  //debug variables
  debug = "True"; //make this true for trouble shooting

  //timing variables
  flashCycle = 0;
  frameCount = 0;
  seconds = 0;
  scheduleTime = 0;
  schedule = 1;

  //background gradient variables
  gradx1 = 0;
  gradx2 = 0;
  gradx3 = 1050;
  gradx4 = 0;

  //color pallet for easy changing
  color = ["Red", "Orange", "Yellow", "Green", "Blue", "Purple"];
  colorCycle = 0;
  currentColor = color[colorCycle];

  //set up the canvas
  pacManCanvas = document.getElementById('pacManCanvas');
  canvas = pacManCanvas.getContext('2d');

  //create any eventlisteners
  window.addEventListener("keydown", keydownfunc);

  //start the gameloop
  startStuff();
}

function startStuff() {
  timer = setInterval(gameLoop, 70);
}


function gameLoop() {
if (play == "True"){
  
  frameCount++;
  
  if (frameCount == 15){
      frameCount = 0;
      seconds = seconds + 1;
  }
  
  //move pacman
  movePacman();

  //move ghost
  moveGhost();
}
  //draw
  draw();

}


//process key events
function keydownfunc() {

  //get key code
  var x = event.keyCode;

  switch (x) {
    case 38: //up arrow

      if (play == "True") {

        direction = "up";

      }
      break;
    case 87: //w key

      if (play == "True") {

        direction = "up";

      }
      break;
    case 40: //down arrow

      if (play == "True") {

        direction = "down";

      }
      break;
    case 83: //s key

      if (play == "True") {

        direction = "down";

      }
      break;
    case 39: //right arrow

      if (play == "True") {

        direction = "right";

      }
      break;
    case 68: //d key

      if (play == "True") {

        direction = "right";

      }
      break;
    case 37: //left arrow

      if (play == "True") {

        direction = "left";

      }
      break;
    case 65: //a key

      if (play == "True") {

        direction = "left";

      }
      break;
    case 13: //enter key

      if (play == "True") {
        play = "False";
      } else if (play == "False") {
        play = "True";
      }

      break;
    default:
      //do nothing
  }
}


//calculate the move for pacman
function movePacman() {

  if (play == "True") {
  
    
    
    //move the pacman
    if (moveComplete == "True") {
      
      if (pacManx == 0 && direction != "right"){
        pacManx = 1050;
      }else if(pacManx == 1050){
       pacManx = -gridSize;
      }
      
      switch (direction) {
        case "up":

          checkMove();

          if (pacCheck == "False") {
            break;
          }

          //calculate new pack man position
          newPacMany = pacMany - gridSize;
          newPacManx = pacManx;

          pacMany = pacMany - 10;
          lastTrueDirection = "up";

          moveComplete = "False";

          break;
        case "down":

          checkMove();

          if (pacCheck == "False") {
            break;
          }

          //calculate new pack man position
          newPacMany = pacMany + gridSize;
          newPacManx = pacManx;

          pacMany = pacMany + 10;
          lastTrueDirection = "down";

          moveComplete = "False";

          break;
        case "left":

          checkMove();

          if (pacCheck == "False") {
            break;
          }

          //calculate new pack man position
          newPacManx = pacManx - gridSize;
          newPacMany = pacMany;

          pacManx = pacManx - 10;
          lastTrueDirection = "left";

          moveComplete = "False";

          break;
        case "right":

          checkMove();

          if (pacCheck == "False") {
            break;
          }

          //calculate new pack man position
          newPacManx = pacManx + gridSize;
          newPacMany = pacMany;

          pacManx = pacManx + 10;
          lastTrueDirection = "right";

          moveComplete = "False";

          break;
        default:
          //this shouldnt happen
      }
    } else if (moveComplete == "False") {

      if (pacManx == newPacManx && pacMany == newPacMany) {
        moveComplete = "True";
        movePacman();
      } else {
        switch (lastTrueDirection) {
          case "up":

            pacMany = pacMany - 10;

            break;
          case "down":

            pacMany = pacMany + 10;
            break;
          case "left":

            pacManx = pacManx - 10;

            break;
          case "right":

            pacManx = pacManx + 10;


          default:
            //this shouldnt happen
        }
      }
    }


  }
}

//make sure the move pacman is going to do is valid.
function checkMove() {

  //find coordinate position
  xGridPos = (pacManx / gridSize);
  yGridPos = (pacMany / gridSize);

  //check collision
  switch (direction) {
    case "up":

      if (levelRow[yGridPos - 1][xGridPos] == 1) {
        pacCheck = "False";
      } else {
        pacCheck = "True";
      }

      break;
    case "down":

      if (levelRow[yGridPos + 1][xGridPos] == 1) {
        pacCheck = "False";
      } else {
        pacCheck = "True";
      }

      break;
    case "left":

      if (levelRow[yGridPos][xGridPos - 1] == 1) {
        pacCheck = "False";
      } else {
        pacCheck = "True";
      }

      break;
    case "right":


      if (levelRow[yGridPos][xGridPos + 1] == 1) {
        pacCheck = "False";
      } else {
        pacCheck = "True";
      }

    default:
      //this shouldnt happen
  }


  //check food/powerup
  if (levelRow[yGridPos][xGridPos] == 0) {//normal dots 
    levelRow[yGridPos][xGridPos] = 2;
    score = score + 10;

  }
  if (levelRow[yGridPos][xGridPos] == 3){//power pellets
    levelRow[yGridPos][xGridPos] = 2;
    score = score + 100;
    mode = "frightened";
    endMode = seconds + 10;
    reverseGhost();
    //ghostSpeed = [10,10,10,10];//this causes problems currently :(
  }

  if (score == maxScore) {
    play = "pac";
    console.log("The pacman wins");

  }
  
  for (i = 0; i < ghostCount; i++){
    
    if (Math.abs(ghostX[i] - pacManx) < (gridSize/1.5) && Math.abs(ghostY[i] - pacMany) < (gridSize/1.5)){
      
      if (mode == "normal" || mode == "scatter"){
      
      play = "ghost";
      
      }else if (mode == "frightened"){
        ghostX[i] = ghostHouse[0];
        ghostY[i] = ghostHouse[1];
        ghostMoveComplete[i] = "True";
        ghostsDirection[i] = "up";
        
      }
    }
  }

}



function moveGhost() { //AI M3

  if (play == "True") {
    // locate the ghost and pacman

    if (endMode == seconds){
      mode = "normal";
      ghostSpeed = [5,5,5,5];
      reverseGhost();
    }
    
    for (i = 0; i < ghostCount; i++) {
      
      if (movementMemory != 0){
        i = movementMemory;
        movementMemory = 0;
      }
      
      
      
      if (ghostSchedule[schedule] == scheduleTime){
        if (mode == "scatter"){
          mode = "normal";
        }else{
          mode = "scatter";
        }
        schedule++;
        scheduleTime = ghostSchedule[schedule] + seconds;
      }
      
      if (mode == "scatter"){
        switch (i){
          case 0:
            pacxGridPos = -1;
            pacyGridPos = -1;
            break;
          case 1:
            pacxGridPos = 35;
            pacyGridPos = -1;
            break;
          case 2:
            pacxGridPos = -1;
            pacyGridPos = 20;
            break;
          case 3:
            pacxGridPos = 36;
            pacyGridPos = 22;
            break;
        }
      }
      
      if (ghostMoveComplete[i] == "True" && seconds >= ghostTimer[i]) {

        ghostxGridPos = [];
        ghostyGridPos = [];

        ghostxGridPos[i] = (ghostX[i] / gridSize);
        ghostyGridPos[i] = (ghostY[i] / gridSize);
        

        if (ghost[i] == 0 && mode == "normal") { //targets directly

          pacxGridPos = (pacManx / gridSize);
          pacyGridPos = (pacMany / gridSize);

        } else if (ghost[i] == 1 && mode == "normal") { //pinkys targeting 4 ahead of pacman
          switch (direction) {
            case "up":
              pacxGridPos = (pacManx / gridSize);
              pacyGridPos = (pacMany / gridSize) - 4;
              break;
            case "down":
              pacxGridPos = (pacManx / gridSize);
              pacyGridPos = (pacMany / gridSize) + 4;
              break;
            case "left":
              pacxGridPos = (pacManx / gridSize) - 4;
              pacyGridPos = (pacMany / gridSize);
              break;
            case "right":
              pacxGridPos = (pacManx / gridSize) + 4;
              pacyGridPos = (pacMany / gridSize);
              break;
            default:
              //shouldnt happen
          }//end switch
        } else if (ghost[i] == 2 && mode == "normal") {

          //calculate distance
          x2 = pacManx;
          y2 = pacMany;

          x1 = ghostX[i];
          y1 = ghostY[i];

          subX = x2 - x1;
          subY = y2 - y1;

          xPow = Math.pow(subX, 2);

          yPow = Math.pow(subY, 2);

          squareRoot = xPow + yPow;

          result = Math.sqrt(squareRoot);

          distance = Math.floor(result);

          if (distance > (10 * gridSize)) {
            pacxGridPos = (pacManx / gridSize);
            pacyGridPos = (pacMany / gridSize);
          } else {
            pacxGridPos = -2;
            pacyGridPos = 22;
          }

         }
      


        //assign some varibles
        leftBox = [];
        rightBox = [];
        topBox = [];
        bottomBox = [];

        leftBox[i] = levelRow[ghostyGridPos[i]][ghostxGridPos[i] - 1];
        rightBox[i] = levelRow[ghostyGridPos[i]][ghostxGridPos[i] + 1];
        topBox[i] = levelRow[ghostyGridPos[i] - 1][ghostxGridPos[i]];
        bottomBox[i] = levelRow[ghostyGridPos[i] + 1][ghostxGridPos[i]];

        
        checkDistance = [];
        
        if (mode != "frightened"){
        //determine direction
        if (leftBox[i] != 1 && ghostLastTrueDirection[i] != "right"){
          checkDistance[0] = distanceCalc(pacxGridPos*gridSize,pacyGridPos*gridSize,ghostX[i] - gridSize,ghostY[i]);
        }else{
          checkDistance[0] = 10000;
        }
        
        if (rightBox[i] != 1 && ghostLastTrueDirection[i] != "left"){
          checkDistance[1] = distanceCalc(pacxGridPos*gridSize,pacyGridPos*gridSize,ghostX[i] + gridSize,ghostY[i]);
        }else{
          checkDistance[1] = 10000;
        }
        
        if (topBox[i] != 1 && ghostLastTrueDirection[i] != "down"){
          checkDistance[2] = distanceCalc(pacxGridPos*gridSize,pacyGridPos*gridSize,ghostX[i],ghostY[i] - gridSize);
        }else{
          checkDistance[2] = 10000;
        }
        
        if (bottomBox[i] != 1 && ghostLastTrueDirection[i] != "up"){
          checkDistance[3] = distanceCalc(pacxGridPos*gridSize,pacyGridPos*gridSize,ghostX[i],ghostY[i] + gridSize);
        }else{
          checkDistance[3] = 10000;
        }
        
        maxDistance = 10000;
        
        if (checkDistance[0] < maxDistance){
          
          maxDistance = checkDistance[0];
          ghostsDirection[i] = "left";
          
        }
        
        if (checkDistance[1] < maxDistance){
          
          maxDistance = checkDistance[1];
          ghostsDirection[i] = "right";
          
        }
        
        if (checkDistance[2] < maxDistance){
          
          maxDistance = checkDistance[2];
          ghostsDirection[i] = "up";
          
        }
        
        if (checkDistance[3] < maxDistance){
          
          maxDistance = checkDistance[3];
          ghostsDirection[i] = "down";
          
        }
        }else if (mode == "frightened"){
          if (leftBox[i] != 1 && ghostLastTrueDirection[i] != "right"){
          checkDistance[0] = Math.floor((Math.random() * 1000) + 1);
        }else{
          checkDistance[0] = 10000;
        }
        
        if (rightBox[i] != 1 && ghostLastTrueDirection[i] != "left"){
          checkDistance[1] = Math.floor((Math.random() * 1000) + 1);
        }else{
          checkDistance[1] = 10000;
        }
        
        if (topBox[i] != 1 && ghostLastTrueDirection[i] != "down"){
          checkDistance[2] = Math.floor((Math.random() * 1000) + 1);
        }else{
          checkDistance[2] = 10000;
        }
        
        if (bottomBox[i] != 1 && ghostLastTrueDirection[i] != "up"){
          checkDistance[3] = Math.floor((Math.random() * 1000) + 1);
        }else{
          checkDistance[3] = 10000;
        }
        
        maxDistance = 10000;
        
        if (checkDistance[0] < maxDistance){
          
          maxDistance = checkDistance[0];
          ghostsDirection[i] = "left";
          
        }
        
        if (checkDistance[1] < maxDistance){
          
          maxDistance = checkDistance[1];
          ghostsDirection[i] = "right";
          
        }
        
        if (checkDistance[2] < maxDistance){
          
          maxDistance = checkDistance[2];
          ghostsDirection[i] = "up";
          
        }
        
        if (checkDistance[3] < maxDistance){
          
          maxDistance = checkDistance[3];
          ghostsDirection[i] = "down";
          
        }
        }
       
      }
      
      
      
    if (ghostMoveComplete[i] == "True" && seconds >= ghostTimer[i]) {

      if (ghostX[i] == 0 && direction != "right"){
        ghostX[i] = 1050;
      }else if(ghostX[i] == 1050){
       ghostX[i] = -gridSize;
      }
      
      //determine the current directine
      switch (ghostsDirection[i]) {
        case "up":


          //calculate new pack man position
          newGhosty[i] = ghostY[i] - gridSize;
          newGhostx[i] = ghostX[i];

          ghostY[i] = ghostY[i] - ghostSpeed[i];

          ghostLastTrueDirection[i] = "up";

          ghostMoveComplete[i] = "False";

          break;
        case "down":


          //calculate new pack man position
          newGhosty[i] = ghostY[i] + gridSize;
          newGhostx[i] = ghostX[i];

          ghostY[i] = ghostY[i] + ghostSpeed[i];

          ghostLastTrueDirection[i] = "down";

          ghostMoveComplete[i] = "False";

          break;
        case "left":


          //calculate new pack man position
          newGhostx[i] = ghostX[i] - gridSize;
          newGhosty[i] = ghostY[i];

          ghostX[i] = ghostX[i] - ghostSpeed[i];

          ghostLastTrueDirection[i] = "left";

          ghostMoveComplete[i] = "False";

          break;
        case "right":

          //calculate new pack man position
          newGhostx[i] = ghostX[i] + gridSize;
          newGhosty[i] = ghostY[i];

          ghostX[i] = ghostX[i] + ghostSpeed[i];

          ghostLastTrueDirection[i] = "right";

          ghostMoveComplete[i] = "False";

          break;
        default:

      }

    } else if (ghostMoveComplete[i] == "False" && seconds >= ghostTimer[i]) {

      if (ghostX[i] == newGhostx[i] && ghostY[i] == newGhosty[i]) {



        ghostMoveComplete[i] = "True";
        
        movementMemory = i;
        moveGhost();

      } else {

        switch (ghostLastTrueDirection[i]) {
          case "up":

            ghostY[i] = ghostY[i] - ghostSpeed[i];

            break;
          case "down":

            ghostY[i] = ghostY[i] + ghostSpeed[i];
            break;
          case "left":

            ghostX[i] = ghostX[i] - ghostSpeed[i];

            break;
          case "right":

            ghostX[i] = ghostX[i] + ghostSpeed[i];


          default:
            //this shouldnt happen
        } //end of switch

      }
    
    }//endif

    }//end of for
    
  } //endif for play

} //end of function

function distanceCalc(x1,y1,x2,y2){

  subX = x2 - x1;
  subY = y2 - y1;

  xPow = Math.pow(subX,2);

  yPow = Math.pow(subY,2);

  squareRoot = xPow + yPow;

  result = Math.sqrt(squareRoot);

  return Math.floor(result);
  
}

function reverseGhost(){
  
//   for (i = 0; i < ghostCount; i++) {
    
//    if (ghostsDirection[i] == "up"){
//       ghostsDirection[i] = "down";
//       ghostLastTrueDirection[i] = "down";
//     }else if (ghostsDirection[i] == "down"){
//       ghostsDirection[i] = "up";
//       ghostLastTrueDirection[i] = "up";
//     }else if (ghostsDirection[i] == "left"){
//       ghostsDirection[i] = "right";
//       ghostLastTrueDirection[i] = "right";
//     }else if (ghostsDirection[i] == "right"){
//       ghostsDirection[i] = "left";
//       ghostLastTrueDirection[i] = "left";
//     }

    
//   }
  
}</script>
  <script>
function draw(){
  
  flashCycle++;
  
  //gradx1 = gradx1 + 1;
  //gradx2 = gradx2 + 2;
  //gradx3 = gradx3 + 3;
  //gradx4 = gradx4 + 4;
  
  //draw background
  canvas.fillStyle = "silver";
  canvas.fillRect(0, 0, 1050, 600);


  //draw textures
  x = 0;
  y = 0;

  //loop through each row
  for (i = 0; i < 20; i++) {

    x = 0;
    //loop through each coulumn
    for (b = 0; b < 35; b++) {
      
       //print walls
      if (levelRow[i][b] == 1){
        
        var gradient = canvas.createLinearGradient(gradx1,gradx2,gradx3,gradx4);
        gradient.addColorStop("0","red");
        gradient.addColorStop("0.33","orange");
        gradient.addColorStop("0.66","red");
        gradient.addColorStop("1.0","orange");

        // Fill with gradient
        canvas.fillStyle=gradient;
        
        canvas.fillRect(x,y,gridSize,gridSize);
        
       //print non walled areas
      }else if (levelRow[i][b] == 0 || levelRow[i][b] == 2 ||levelRow[i][b] == 3 || levelRow[i][b] == 10){
        
        canvas.fillStyle = "black";
        canvas.fillRect(x,y,gridSize,gridSize);
        
      }
      
      //draw any pellets
      if (levelRow[i][b] == 0){
        
        canvas.beginPath();
        canvas.arc(x + (gridSize/2),y + (gridSize/2),3,0,2 * Math.PI);
        canvas.fillStyle = "tan";
        canvas.fill();
        
        //draw super pellets
      } else if (levelRow[i][b] == 3){
        
        canvas.beginPath();
        canvas.arc(x + (gridSize/2),y + (gridSize/2),7,0,2 * Math.PI);
        
        if (flashCycle < 4){
          canvas.fillStyle = "tan";
          canvas.fill();
        }
        
        
      }
      
      //increment coulumn to be printed
      x = x + gridSize;

    }

    //incremnt row to be printed
    y = y + gridSize;

  }

  //title and score
  canvas.font = gridSize + "px Georgia";
  canvas.fillStyle = "Yellow";
  canvas.fillText("PacMan!", (gridSize * 16) - (gridSize/2),(gridSize*1) - (gridSize/4));
  
  //print different status messages
  if (play == "False" ){//press enter to play
    
    canvas.font = gridSize + "px Georgia";
    canvas.fillStyle = "red";
    canvas.fillText("Press Enter to Play!", gridSize * 13,(gridSize * 9) - (gridSize/4));
    
  }else if(play == "pac"){//win message
    
    canvas.font = "30px Georgia";
    canvas.fillStyle = "red";
    canvas.fillText("You Win!!", gridSize * 16,(gridSize * 9) - (gridSize/4));
    
  }else if(play == "ghost"){//ghost win message
    
    canvas.font = gridSize + "px Georgia";
    canvas.fillStyle = "red";
    canvas.fillText("The Ghosts Win :(", (gridSize * 13) - (gridSize/2),(gridSize * 9) - (gridSize/4));
  }
  
//save canvas due to rotations that may happen
  canvas.save();
  
  //determine which orientation pacman should be printed in
  switch (lastTrueDirection) {
  case "up":
      canvas.translate(pacManx,pacMany + gridSize);
      
      canvas.rotate(-Math.PI / 2);

    break;
  case "down":
      canvas.translate(pacManx + gridSize,pacMany);
      
      canvas.rotate(Math.PI / 2);

    break;
  case "left":
      canvas.translate(pacManx + gridSize,pacMany + gridSize);
      
      canvas.rotate(-Math.PI);
      
    break;
  case "right":
      canvas.translate(pacManx,pacMany);
    break;
  default:
    //shouldnt happen
}



//draw pacman
  
canvas.beginPath();//top
canvas.arc((gridSize/2),(gridSize/2), (gridSize/2) - (gridSize * (1/10)), topMouthAngle, Math.PI * 1.07);
canvas.fillStyle = "Yellow";
canvas.fill();
  
canvas.beginPath();//bottom
canvas.arc((gridSize/2),(gridSize/2), (gridSize/2) - (gridSize * (1/10)), -Math.PI * 1.07,-bottomMouthAngle);
canvas.fillStyle = "Yellow";
canvas.fill();


//decide the mouth angle
if (play == "True" && pacCheck == "True"){
switch (topMouthAngle) {
  case 0:
    topMouthAngle = Math.PI/6;
    bottomMouthAngle = Math.PI/6;
    break;
  case Math.PI/6:
    topMouthAngle = 0;
    bottomMouthAngle = 0;
    break;

}
  
}

  //restore the canvas to original state
canvas.restore();

  //draw the ghost

  for (i = 0; i < ghostCount; i++){
    
    if (mode == "frightened"){
      if (endMode - seconds < 5){
        if (flashCycle < 4){
          canvas.fillStyle = "Blue";
        }else{
          canvas.fillStyle = "Grey";
        }
      }else{
      canvas.fillStyle = "Blue";
      }
    }else{
        canvas.fillStyle = ghostColor[i];
    }
    

    
  //main body 
  canvas.fillRect(ghostX[i] + (gridSize * (1.5/10)),ghostY[i] + (gridSize * (3/10)),gridSize - (gridSize * (3/10)),gridSize - (gridSize * (5/10)));
  canvas.beginPath();
  //head
  canvas.arc(ghostX[i] + (gridSize/2),ghostY[i] + ((gridSize/2) - (gridSize * (1/10))),gridSize/2 - (gridSize * (1.5/10)),0,2 * Math.PI);
  canvas.fill();
  //tenticals
  if (flashCycle < 4){
    canvas.save();
    
    canvas.translate(ghostX[i] + (gridSize * (1/20)),ghostY[i]);
    canvas.rotate(45 * Math.PI/180);
    
    //tenticals
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
    
    canvas.rotate(-45 * Math.PI/180);
    canvas.translate(-((gridSize/3) - (gridSize/10)),0);
    canvas.rotate(45 * Math.PI/180);
    
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
   
    canvas.rotate(-45 * Math.PI/180);
    canvas.translate(-((gridSize/3) - (gridSize/10)),0);
    canvas.rotate(45 * Math.PI/180);
    
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
  
    canvas.restore();
  }else{
    
    canvas.save();
    
    canvas.translate(ghostX[i] + (gridSize * (3/20)),ghostY[i]);
    canvas.rotate(45 * Math.PI/180);
    
    //tenticals
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
    
    canvas.rotate(-45 * Math.PI/180);
    canvas.translate(-((gridSize/3) - (gridSize/10)),0);
    canvas.rotate(45 * Math.PI/180);
    
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
   
    canvas.rotate(-45 * Math.PI/180);
    canvas.translate(-((gridSize/3) - (gridSize/10)),0);
    canvas.rotate(45 * Math.PI/180);
    
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
  
    canvas.rotate(-45 * Math.PI/180);
    canvas.translate(-((gridSize/3) - (gridSize/10)),0);
    canvas.rotate(45 * Math.PI/180);
    
    canvas.fillRect(gridSize - (gridSize/gridSize),0,(gridSize/4) - (gridSize/10),(gridSize/4) - (gridSize/10));
  
    
    canvas.restore();
    canvas.save();
    

    canvas.translate(ghostX[i] + (gridSize * (1/20)),ghostY[i]);

    canvas.fillStyle = "black";
    
    canvas.fillRect(0 - (gridSize/20),gridSize - (gridSize/3),(gridSize/4) - (gridSize/10),(gridSize/4));
    
    canvas.fillRect((gridSize * (1/10)) + gridSize - (gridSize * (3/10)),gridSize - (gridSize/3),(gridSize/4) - (gridSize/10),(gridSize/4));
    
    canvas.restore();
    
  }
  
  canvas.fillStyle = "White";
  canvas.beginPath();
  canvas.arc(ghostX[i] + (gridSize * (1/3)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/8)),0,2*Math.PI);
  canvas.fill();
  
   canvas.beginPath();
  canvas.arc(ghostX[i] + (gridSize * (2/3)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/8)),0,2*Math.PI);
  canvas.fill();
  
  if (ghostsDirection[i] == "up"){
    
    canvas.fillStyle = "Blue";
    canvas.beginPath();
    //pupils
    canvas.arc(ghostX[i] + (gridSize * (1/3)),ghostY[i] + (gridSize * (1/3)) - (gridSize * (1/20)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    canvas.arc(ghostX[i] + (gridSize * (2/3)),ghostY[i] + (gridSize * (1/3)) - (gridSize * (1/20)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    
  }else if (ghostsDirection[i] == "down"){
    
    canvas.fillStyle = "Blue";
    canvas.beginPath();
    //pupils
    canvas.arc(ghostX[i] + (gridSize * (1/3)),ghostY[i] + (gridSize * (1/3)) + (gridSize * (1/20)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    canvas.arc(ghostX[i] + (gridSize * (2/3)),ghostY[i] + (gridSize * (1/3)) + (gridSize * (1/20)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    
  }else if (ghostsDirection[i] == "left"){
    
    canvas.fillStyle = "Blue";
    canvas.beginPath();
    //pupils
    canvas.arc(ghostX[i] + (gridSize * (1/3)) - (gridSize * (1/20)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    canvas.arc(ghostX[i] + (gridSize * (2/3)) - (gridSize * (1/20)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    
  }else if (ghostsDirection[i] == "right"){
    
    canvas.fillStyle = "Blue";
    canvas.beginPath();
    //pupils
    canvas.arc(ghostX[i] + (gridSize * (1/3)) + (gridSize * (1/20)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    canvas.arc(ghostX[i] + (gridSize * (2/3)) + (gridSize * (1/20)),ghostY[i] + (gridSize * (1/3)),(gridSize * (1/15)),0,2*Math.PI);
    canvas.fill();
    
  
}
 
  
  
  //needs fixed 
if (debug == "True" && play == "True"){

  //leftBox  
  if (leftBox[i] == 1){
    colorCycle = 0;
  }else{
    colorCycle = 3;
  }
  if (ghostTurnDirection1[i] == "left"){
    colorCycle = 2;
  }

  canvas.fillStyle = color[colorCycle];
  canvas.fillRect((ghostxGridPos[i] - 1) * gridSize,ghostyGridPos[i] * gridSize,gridSize,gridSize);
  
  //rightBox
  if (rightBox[i] == 1){
    colorCycle = 0;
  }else{
    colorCycle = 3;
  }
  if (ghostTurnDirection1[i] == "right"){
    colorCycle = 2;
  }
  
  canvas.fillStyle = color[colorCycle];
  canvas.fillRect((ghostxGridPos[i] + 1) * gridSize,ghostyGridPos[i] * gridSize,gridSize,gridSize);
  
  //topBox
  if (topBox[i] == 1){
    colorCycle = 0;
  }else{
    colorCycle = 3;
  }
  if (ghostTurnDirection2[i] == "up"){
    colorCycle = 2;
  }
  
  canvas.fillStyle = color[colorCycle];
  canvas.fillRect(ghostxGridPos[i] * gridSize,(ghostyGridPos[i] - 1) * gridSize,gridSize,gridSize);
  
  //bottomBox
  if (bottomBox[i] == 1){
    colorCycle = 0;
  }else{
    colorCycle = 3;
  }
  if (ghostTurnDirection2[i] == "down"){
    colorCycle = 2;
  }
  
  canvas.fillStyle = color[colorCycle];
  canvas.fillRect(ghostxGridPos[i] * gridSize,(ghostyGridPos[i] + 1) * gridSize,gridSize,gridSize);
  
  
}
  
  //score
  canvas.font = "30px Arial";
  canvas.fillStyle = "white";
  canvas.fillText("Score: "+ score,(gridSize * 15) + (gridSize/2),(gridSize * 20) - (gridSize/4));
    
 //time
 canvas.fillText("Time: "+ seconds,(gridSize * 5) + (gridSize/2),(gridSize * 20) - (gridSize/4));
  
 if (flashCycle == 6){
   flashCycle = 0;
 } 
}
}</script>
</head>

<body onload="init()">

  <center>

    <div class="canvasPositioningFrame">
      <canvas id='pacManCanvas' height='600px' width='1050px'>If you see this you must still be in 2005!</canvas>
    </div>
  </center>

</body>

</html>